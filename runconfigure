#!/bin/bash
# Automatically fail when any command fails:
#set -e
# Echo cmds as they are performed
#set -x

# setvar_chk: Set variable defined by string in $1 to one of the values in array @2.
#             Default is first element of @2
function setvar_chk () {
  if test "$#" -lt 2; then
    echo "${FUNCNAME[0]}: requires at least 2 args: varname, array of valids"
    exit 1
  fi

  local varname=$1
  shift
  local validvals=($@)
  local defans=${validvals[0]}
  local ans

  while [ true ]; do
    ans=''
    echo -n "Enter $varname (${validvals[@]}) [$defans]"
    read ans < /dev/stdin
    if [[ -z $ans ]]; then
      ans=$defans
    fi
  
    for i in "${validvals[@]}"; do
      if [[ $ans == $i ]]; then break; fi
    done
    if [[ $ans == $i ]]; then
      break
    else
      echo "$ans not in list: ${validvals[@]}"
    fi
  done
  eval "$varname=\$ans"
}

########################## Begin main script ####################################

# Base command for GPU build with all required settings plus OpenACC
cmd="env CC=nvc FC=nvfortran ./configure --disable-shared --disable-openmp --with-nvcc=nvcc --enable-cacc --enable-facc"

# Add options
declare -a defyes=("y" "n")
declare -a defno=("n" "y")
declare -a defnonum=("n" 16 24 32 48 64 96 128)
declare -a validccab=(35 37 50 52 53 60 61 62 70 72 75 80 86 87)

printf "prefix is where the library will be installed\n"
defans="${HOME}/install/gptl_cuda_placebo"
ans=''
echo -n "enter prefix [$defans]"
read ans < /dev/stdin
if [[ -z $ans ]]; then
  ans=$defans
fi
newcmd="$cmd --prefix=$ans"
cmd="$newcmd"

printf "debug adds overhead to both CPU and GPU\n"
setvar_chk "debug" ${defno[@]}
printf "debug is $debug\n\n"
if [[ $debug == "y" ]]; then
  newcmd="$cmd --enable-debug"
  cmd="$newcmd"
fi

printf "Do you want to change compute capability from default value of 61?"
setvar_chk "setccab" ${defno[@]}
if [[ $setccab == "y" ]]; then
  setvar_chk "ccab" ${validccab[@]}
  printf "ccab is $ccab\n\n"
  if [[ $setccab != "n" ]]; then
    newcmd="$cmd --with-ccab=$ccab"
    cmd="$newcmd"
  fi
fi

echo "Hit return to run:"
echo "${cmd}"
read ans < /dev/stdin
$cmd 2>&1 | tee out
echo "$cmd" > out.configure
cat out >> out.configure
exit 0
